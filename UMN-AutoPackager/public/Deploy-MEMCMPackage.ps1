function Deploy-MEMCMPackage {
    <#
    .SYNOPSIS
    Creates deployments in Configuration Manager based on the values of the UMNAutopackager json files.
    .DESCRIPTION
    This command creates new deployment(s) for each site based on the values of the GlobalConfig and PackageConfig json values. It leverages various powershell commands provided with ConfigMgr.
    .PARAMETER GlobalConfig
    Input the global configuration json file using the Get-GlobalConfig command
    .PARAMETER PackageDefinition
    Input the package definition json file using the Get-GlobalConfig command
    .PARAMETER Credential
    Input the credentials object or the user name which will prompt for credentials. If not called will attempt to use the credentials of the account that is running the script.
    .EXAMPLE
    Deploy-MEMCMPackage -GlobalConfig (Get-UMNGlobalConfig -Path C:\UMNAutopackager\GlobalConfig.json) -PackageDefinition (Get-UMNGlobalConfig -Path C:\UMNAutopackager\PackageConfig.json) -Credential MyUserName
    Runs the function prompting for the credentials of MyUserName.
    .EXAMPLE
    Deploy-MEMCMPackage -GlobalConfig $globaljson -PackageDefinition $pkgjson -Credential $creds
    Runs the function using the credentials stored in the $creds variable.
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true,
            HelpMessage = "Input the values of the GlobalConfig.json.")]
        [psobject]$GlobalConfig,
        [Parameter(Mandatory = $true,
            HelpMessage = "Input the values of the various packagedefinition.json files.")]
        [psobject[]]$PackageDefinition,
        [ValidateNotNull()]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential = [System.Management.Automation.PSCredential]::Empty
    )
    begin {
        Write-Verbose -Message "Starting $($myinvocation.mycommand)"
        Import-Module -Name "$($env:SystemDrive)\Program Files (x86)\Microsoft Endpoint Manager\AdminConsole\bin\ConfigurationManager.psd1"
    }
    process {
        foreach ($ConfigMgrObject in ($GlobalConfig.packagingTargets)) {
            Write-Verbose -Message "Processing $($ConfigMgrObject.site) Site..."
            $SiteCode = $ConfigMgrObject.SiteCode
            try {
                if (-not (Test-Path -Path $SiteCode)) {
                    $ConfigMgrDrive = New-PSDrive -Name $SiteCode -PSProvider CMSite -Root $ConfigMgrObject.Site -Credential $Credential
                }
            }
            catch {
                Write-Error $Error[0]
                Write-Warning -Message "Error: $($_.Exception.Message)"
            }
            Push-Location
            Set-Location -Path "$SiteCode`:\"
# ask about the baseappname it is replaced with the prefix and suffix I will assume the Application Name will be generated by the set command
# Clear out any troubleshooting write-Outputs
# Fix and test the global json if section
# Update the global and package json with the DeploymentSettings - the s was missing on some of them.
            foreach ($PkgObject in $PackageDefinition) {
                Write-Verbose -Message "Processing the package definition for $($pkgObject.publisher) $($pkgObject.productname)"
                # Check if the application exists if it does continue with building deployments
                if (($PkgObject.overridePackagingTargets -eq $True) -and ($PkgObject.packagingTargets.type -eq "MEMCM-Application")) {
                    if (Get-CMApplication -Name $PkgObject.packagingTargets.name) {
                        Write-Verbose -Message "Application $($PkgObject.packagingTargets.name) exists"
                        foreach ($collection in $PkgObject.packagingTargets.collectionTargets) {
                            Write-Verbose -Message "Checking for deployment settings on Collection Target: $($collection.name)"
                            if ($collection.deploymentSettings) {
                                Write-Verbose -Message "Checking if the collection $($collection.name) exists"
                                if (Get-CMCollection -Name $collection.Name) {
                                    Write-Verbose -Message "Checking if the collection has any deployments"
                                    if (Get-CMApplicationDeployment -CollectionName $collection.name) {
                                        Write-Verbose -Message "$($collection.name) contains deployments"
                                        $deployments = Get-CMApplicationDeployment -CollectionName "$($collection.name)"
                                        foreach ($deploy in $deployments) {
                                            if ($deploy.ApplicationName -match $PkgObject.publisher -and $deploy.ApplicationName -match $pkgObject.productName) {
                                                Write-Verbose -Message "$($deploy.ApplicationName) matches the publisher and product name of an existing deployment, removing deployment"
                                                try {
                                                    Remove-CMApplicationDeployment -Name "$($deploy.ApplicationName)" -CollectionName "$($collection.name)" -Force -ErrorAction Stop
                                                }
                                                catch {
                                                    Write-Error $Error[0]
                                                    Write-Warning -Message "Error: $($_.Exception.Message)"
                                                }
                                            }
                                            else {
                                                Write-Verbose -Message "No matching deployment found"
                                            }
                                        }
                                    }
                                    else {
                                        Write-Verbose -Message "The collection: $($collection.name) does not have an existing deployment"
                                    }
                                    Write-Verbose -Message "Building deployment..."
                                    $DeploymentArguments = @{
                                        Name                               = $pkgObject.packagingTargets.Name
                                        CollectionName                     = $collection.Name
                                        AllowRepairApp                     = $collection.deploymentSettings.allowRepairApp
                                        DeployAction                       = $collection.deploymentSettings.DeployAction
                                        DeployPurpose                      = $collection.deploymentSettings.DeployPurpose
                                        OverrideServiceWindow              = $collection.deploymentSettings.OverrideServiceWindow
                                        PreDeploy                          = $collection.deploymentSettings.PreDeploy
                                        RebootOutsideServiceWindow         = $collection.deploymentSettings.RebootOutsideServiceWindow
                                        ReplaceToastNotificationWithDialog = $collection.deploymentSettings.ReplaceToastNotificationWithDialog
                                        SendWakeupPacket                   = $collection.deploymentSettings.SendWakeupPacket
                                        TimeBaseOn                         = $collection.deploymentSettings.TimeBaseOn
                                        UserNotification                   = $collection.deploymentSettings.userNotification
                                        AvailableDateTime                  = ""
                                        DeadlineDateTime                   = ""
                                        ErrorAction                        = "Stop"
                                    }
                                    # Setting Date Times for available
                                    if ($collection.deploymentSettings.availStart) {
                                        Write-Verbose -Message "availStart: $($collection.deploymentSettings.availStart)"
                                        $availtime = (Get-Date -Hour $collection.deploymentSettings.availHour -Minute $collection.deploymentSettings.availMinute).AddDays($collection.DeploymentSettings.availstart)
                                        $DeploymentArguments.set_item("AvailableDateTime" , $availtime)
                                    }
                                    else {
                                        Write-Verbose -Message "No availStart setting as current date and time"
                                        $DeploymentArguments.set_item("AvailableDateTime" , (Get-Date))
                                    }
                                    # Setting Date Times for deadline
                                    if ($collection.deploymentSettings.deadlineStart) {
                                        Write-Verbose -Message "deadlineStart: $($collection.deploymentSettings.deadlineStart)"
                                        $deadlinetime = (Get-Date -Hour $collection.deploymentSettings.deadlineHour -Minute $collection.deploymentSettings.deadlineMinute).AddDays($collection.DeploymentSettings.deadlineStart)
                                        $DeploymentArguments.set_item("DeadlineDateTime" , $deadlinetime)
                                    }
                                    else {
                                        Write-Verbose -Message "No deadlineStart"
                                    }
                                    # Removing null or empty values from the hashtable
                                    $list = New-Object System.Collections.ArrayList
                                    foreach ($DepA in $DeploymentArguments.Keys) {
                                        if ([string]::IsNullOrWhiteSpace($DeploymentArguments.$DepA)) {
                                            $null = $list.Add($DepA)
                                        }
                                    }
                                    foreach ($item in $list) {
                                        $DeploymentArguments.Remove($item)
                                    }
                                    try {
                                        Write-Verbose -Message "Creating deployment of Application: $NewAppName for collection: $($collection.name)"
                                        New-CMApplicationDeployment @DeploymentArguments
                                    }
                                    catch {
                                        Write-Error $Error[0]
                                        Write-Warning -Message "Error: $($_.Exception.Message)"
                                    }
                                    # Creates the time as UTC regardless of TimeBaseOn switch being set to LocalTime setting the date time
                                    if ($collection.deploymentSettings.timeBaseOn -eq "LocalTime" -and $collection.deploymentSettings.deadlineStart) {
                                        Write-Verbose -Message "Time based on LocalTime and deadline start has a value"
                                        Set-CMApplicationDeployment -ApplicationName $DeploymentArguments.Name -CollectionName $deploymentArguments.CollectionName -DeadlineDatetime $DeploymentArguments.DeadlineDateTime -AvailableDateTime $DeploymentArguments.AvailableDateTime
                                    }
                                    elseif ($collection.deploymentSettings.timeBaseOn -eq "LocalTime" -and (-not $collection.deploymentSettings.deadlineStart)) {
                                        Write-Verbose -Message "Time based on LocalTime and no deadline start value"
                                        Set-CMApplicationDeployment -ApplicationName $DeploymentArguments.Name -CollectionName $deploymentArguments.CollectionName -AvailableDateTime $DeploymentArguments.AvailableDateTime
                                    }
                                }
                                else {
                                    Write-Verbose -Message "$($collection.Name) does not exist or is not a MEMCM-Collection type."
                                }
                            }
                            else {
                                Write-Verbose -Message "$($collection.Name) has no deploymentSettings in JSON"
                            }
                        }#foreach $collections
                    }
                }
                if (($PkgObject.overridePackagingTargets -eq $false) -and ($GlobalConfig.packagingTargets.type -eq "MEMCM-Application")) {
                    if (Get-CMApplication -Name $PkgObject.packagingTargets.name) {
                        foreach ($collection in $PkgObject.CollectionTargets) {
                            Write-Verbose -Message "Checking for deployment settings on Collection Target: $($collection.name)"
                            if ($collection.deploymentSettings) {
                                Write-Verbose -Message "Checking it is a MEMCM-Collection and the $($collection.name) exist"
                                if (($collection.type -eq "MEMCM-Collection") -and (Get-CMCollection -Name $collection.Name)) {
                                    Write-Verbose -Message "Checking if the collection has any deployments"
                                    if (Get-CMApplicationDeployment -CollectionName $collection.name) {
                                        Write-Verbose -Message "$($collection.name) contains deployments"
                                        $deployments = Get-CMApplicationDeployment -CollectionName $collection.name
                                        # If deployment(s) exist for each check if the deployment name contains the publisher and product name
                                        foreach ($deploy in $deployments) {
                                            if ($deploy.ApplicationName -match $PkgObject.publisher -and $deploy.ApplicationName -match $pkgObject.productName) {
                                                Write-Verbose -Message "$($deploy.ApplicationName) matches the publisher and product name of an existing deployment, removing deployment"
                                                try {
                                                    Remove-CMApplicationDeployment -Name $deploy.ApplicationName -CollectionName $collection.name -Force
                                                }
                                                catch {
                                                    Write-Error $Error[0]
                                                    Write-Warning -Message "Error: $($_.Exception.Message)"
                                                }
                                            }
                                        }
                                    }
                                    Write-Verbose -Message "Building deployment..."
                                    $DeploymentArguments = @{
                                        Name                               = $pkgObject.packagingTargets.Name
                                        CollectionName                     = $collection.Name
                                        AllowRepairApp                     = $collection.deploymentSettings.allowRepairApp
                                        DeployAction                       = $collection.deploymentSettings.DeployAction
                                        DeployPurpose                      = $collection.deploymentSettings.DeployPurpose
                                        OverrideServiceWindow              = $collection.deploymentSettings.OverrideServiceWindow
                                        PreDeploy                          = $collection.deploymentSettings.PreDeploy
                                        RebootOutsideServiceWindow         = $collection.deploymentSettings.RebootOutsideServiceWindow
                                        ReplaceToastNotificationWithDialog = $collection.deploymentSettings.ReplaceToastNotificationWithDialog
                                        SendWakeupPacket                   = $collection.deploymentSettings.SendWakeupPacket
                                        TimeBaseOn                         = $collection.deploymentSettings.TimeBaseOn
                                        UserNotification                   = $collection.deploymentSettings.userNotification
                                        AvailableDateTime                  = ""
                                        DeadlineDateTime                   = ""
                                    }
                                    # Setting Date Times for available
                                    if ($collection.deploymentSettings.availStart) {
                                        Write-Verbose -Message "availStart: $($collection.deploymentSettins.availStart)"
                                        $availtime = (Get-Date -Hour $collection.deploymentSettings.availHour -Minute $collection.deploymentSettings.availMinute).AddDays($collection.DeploymentSettings.availstart)
                                        $DeploymentArguments.set_item("AvailableDateTime" , $availtime)
                                    }
                                    else {
                                        Write-Verbose -Message "No availStart setting as current date and time"
                                        $DeploymentArguments.set_item("AvailableDateTime" , (Get-Date))
                                    }
                                    # Setting Date Times for deadline
                                    if ($collection.deploymentSettings.deadlineStart) {
                                        Write-Verbose -Message "deadlineStart: $($collection.deploymentSettings.deadlineStart)"
                                        $deadlinetime = (Get-Date -Hour $collection.deploymentSettings.deadlineHour -Minute $collection.deploymentSettings.deadlineMinute).AddDays($collection.DeploymentSettings.deadlineStart)
                                        $DeploymentArguments.set_item("DeadlineDateTime" , $deadlinetime)
                                    }
                                    else {
                                        Write-Verbose -Message "No deadlineStart"
                                    }
                                    # Removing null or empty values from the hashtable
                                    $list = New-Object System.Collections.ArrayList
                                    foreach ($DepA in $DeploymentArguments.Keys) {
                                        if ([string]::IsNullOrWhiteSpace($DeploymentArguments.$DepA)) {
                                            $null = $list.Add($DepA)
                                        }
                                    }
                                    foreach ($item in $list) {
                                        $DeploymentArguments.Remove($item)
                                    }
                                    try {
                                        Write-Verbose -Message "Creating deployment of Application: $NewAppName for collection: $($collection.name)"
                                        New-CMApplicationDeployment @DeploymentArguments
                                    }
                                    catch {
                                        Write-Error $Error[0]
                                        Write-Warning -Message "Error: $($_.Exception.Message)"
                                    }
                                    # Creates the time as UTC regardless of TimeBaseOn switch being set to LocalTime setting the date time
                                    if ($collection.deploymentSettings.timeBaseOn -eq "LocalTime" -and $collection.deploymentSettings.deadlineStart) {
                                        Write-Verbose -Message "Time based on LocalTime and deadline start has a value"
                                        Set-CMApplicationDeployment -ApplicationName $DeploymentArguments.Name -CollectionName $deploymentArguments.CollectionName -DeadlineDatetime $DeploymentArguments.DeadlineDateTime -AvailableDateTime $DeploymentArguments.AvailableDateTime
                                    }
                                    elseif ($collection.deploymentSettings.timeBaseOn -eq "LocalTime" -and (-not $collection.deploymentSettings.deadlineStart)) {
                                        Write-Verbose -Message "Time based on LocalTime and no deadline start value"
                                        Set-CMApplicationDeployment -ApplicationName $DeploymentArguments.Name -CollectionName $deploymentArguments.CollectionName -AvailableDateTime $DeploymentArguments.AvailableDateTime
                                    }
                                }
                                else {
                                    Write-Verbose -Message "$($collection.Name) does not exist or is not a MEMCM-Collection type."
                                }
                            }
                        }#foreach $CollectionTargets
                    }
                }
            }#foreach $PackageDefinition
            Pop-Location
            $ConfigMgrDrive | Remove-PSDrive
        }#foreach $ConfigMgrObject
    }
    end {
        Write-Verbose -Message "Ending $($myinvocation.mycommand)"
    }
}#Deploy-MEMCMPackage